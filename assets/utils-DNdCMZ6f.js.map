{"version":3,"file":"utils-DNdCMZ6f.js","sources":["../../src/utils/isScreenTouchEnabled.ts","../../node_modules/three-stdlib/utils/BufferGeometryUtils.js","../../node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js","../../node_modules/troika-three-utils/dist/troika-three-utils.esm.js","../../src/utils/getLang.tsx","../../src/utils/pointerEvents.ts","../../src/utils/isProduction.ts"],"sourcesContent":["export const isScreenTouchEnabled = () => {\n  let hasTouchScreen = false;\n  if (\"maxTouchPoints\" in navigator) {\n    hasTouchScreen = navigator.maxTouchPoints > 0;\n  } else if (\"msMaxTouchPoints\" in navigator) {\n    hasTouchScreen = navigator[\"msMaxTouchPoints\"] > 0;\n  } else {\n    const mQ = matchMedia?.(\"(pointer:coarse)\");\n    if (mQ?.media === \"(pointer:coarse)\") {\n      hasTouchScreen = !!mQ.matches;\n    } else if (\"orientation\" in window) {\n      hasTouchScreen = true; // deprecated, but good fallback\n    } else {\n      // Only as a last resort, fall back to user agent sniffing\n      const UA = navigator[\"userAgent\"];\n      hasTouchScreen =\n        /\\b(BlackBerry|webOS|iPhone|IEMobile)\\b/i.test(UA) ||\n        /\\b(Android|Windows Phone|iPad|iPod)\\b/i.test(UA);\n    }\n  }\n\n  return hasTouchScreen;\n};\n","import { BufferGeometry, BufferAttribute, InterleavedBuffer, InterleavedBufferAttribute, TrianglesDrawMode, TriangleFanDrawMode, TriangleStripDrawMode, Vector3, Float32BufferAttribute } from \"three\";\nimport { getWithKey } from \"../types/helpers.js\";\nconst mergeBufferGeometries = (geometries, useGroups) => {\n  const isIndexed = geometries[0].index !== null;\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));\n  const attributes = {};\n  const morphAttributes = {};\n  const morphTargetsRelative = geometries[0].morphTargetsRelative;\n  const mergedGeometry = new BufferGeometry();\n  let offset = 0;\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0;\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.\"\n      );\n      return null;\n    }\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.'\n        );\n        return null;\n      }\n      if (attributes[name] === void 0) {\n        attributes[name] = [];\n      }\n      attributes[name].push(geom.attributes[name]);\n      attributesCount++;\n    }\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". Make sure all geometries have the same number of attributes.\"\n      );\n      return null;\n    }\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". .morphTargetsRelative must be consistent throughout all geometries.\"\n      );\n      return null;\n    }\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \".  .morphAttributes must be consistent throughout all geometries.\"\n        );\n        return null;\n      }\n      if (morphAttributes[name] === void 0)\n        morphAttributes[name] = [];\n      morphAttributes[name].push(geom.morphAttributes[name]);\n    }\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n    mergedGeometry.userData.mergedUserData.push(geom.userData);\n    if (useGroups) {\n      let count;\n      if (geom.index) {\n        count = geom.index.count;\n      } else if (geom.attributes.position !== void 0) {\n        count = geom.attributes.position.count;\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index \" + i + \". The geometry must have either an index or a position attribute\"\n        );\n        return null;\n      }\n      mergedGeometry.addGroup(offset, count, i);\n      offset += count;\n    }\n  });\n  if (isIndexed) {\n    let indexOffset = 0;\n    const mergedIndex = [];\n    geometries.forEach((geom) => {\n      const index = geom.index;\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset);\n      }\n      indexOffset += geom.attributes.position.count;\n    });\n    mergedGeometry.setIndex(mergedIndex);\n  }\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name]);\n    if (!mergedAttribute) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" attribute.\"\n      );\n      return null;\n    }\n    mergedGeometry.setAttribute(name, mergedAttribute);\n  }\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length;\n    if (numMorphTargets === 0)\n      break;\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n    mergedGeometry.morphAttributes[name] = [];\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = [];\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i]);\n      }\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n      if (!mergedMorphAttribute) {\n        console.error(\n          \"THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the \" + name + \" morphAttribute.\"\n        );\n        return null;\n      }\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n    }\n  }\n  return mergedGeometry;\n};\nconst mergeBufferAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let itemSize = void 0;\n  let normalized = void 0;\n  let arrayLength = 0;\n  attributes.forEach((attr) => {\n    if (TypedArray === void 0) {\n      TypedArray = attr.array.constructor;\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.\"\n      );\n      return null;\n    }\n    if (itemSize === void 0)\n      itemSize = attr.itemSize;\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    if (normalized === void 0)\n      normalized = attr.normalized;\n    if (normalized !== attr.normalized) {\n      console.error(\n        \"THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.\"\n      );\n      return null;\n    }\n    arrayLength += attr.array.length;\n  });\n  if (TypedArray && itemSize) {\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset);\n      offset += attr.array.length;\n    });\n    return new BufferAttribute(array, itemSize, normalized);\n  }\n};\nconst interleaveAttributes = (attributes) => {\n  let TypedArray = void 0;\n  let arrayLength = 0;\n  let stride = 0;\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i];\n    if (TypedArray === void 0)\n      TypedArray = attribute.array.constructor;\n    if (TypedArray !== attribute.array.constructor) {\n      console.error(\"AttributeBuffers of different types cannot be interleaved\");\n      return null;\n    }\n    arrayLength += attribute.array.length;\n    stride += attribute.itemSize;\n  }\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n  let offset = 0;\n  const res = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  const setters = [\"setX\", \"setY\", \"setZ\", \"setW\"];\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j];\n    const itemSize = attribute.itemSize;\n    const count = attribute.count;\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n    res.push(iba);\n    offset += itemSize;\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k]);\n        const get = getWithKey(attribute, getters[k]);\n        set(c, get(c));\n      }\n    }\n  }\n  return res;\n};\nfunction estimateBytesUsed(geometry) {\n  let mem = 0;\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name);\n    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n  }\n  const indices = geometry.getIndex();\n  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n  return mem;\n}\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n  tolerance = Math.max(tolerance, Number.EPSILON);\n  const hashToIndex = {};\n  const indices = geometry.getIndex();\n  const positions = geometry.getAttribute(\"position\");\n  const vertexCount = indices ? indices.count : positions.count;\n  let nextIndex = 0;\n  const attributeNames = Object.keys(geometry.attributes);\n  const attrArrays = {};\n  const morphAttrsArrays = {};\n  const newIndices = [];\n  const getters = [\"getX\", \"getY\", \"getZ\", \"getW\"];\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    attrArrays[name] = [];\n    const morphAttr = geometry.morphAttributes[name];\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => []);\n    }\n  }\n  const decimalShift = Math.log10(1 / tolerance);\n  const shiftMultiplier = Math.pow(10, decimalShift);\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i;\n    let hash = \"\";\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.getAttribute(name);\n      const itemSize = attribute.itemSize;\n      for (let k = 0; k < itemSize; k++) {\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`;\n      }\n    }\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash]);\n    } else {\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j];\n        const attribute = geometry.getAttribute(name);\n        const morphAttr = geometry.morphAttributes[name];\n        const itemSize = attribute.itemSize;\n        const newarray = attrArrays[name];\n        const newMorphArrays = morphAttrsArrays[name];\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k];\n          newarray.push(attribute[getterFunc](index));\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n            }\n          }\n        }\n      }\n      hashToIndex[hash] = nextIndex;\n      newIndices.push(nextIndex);\n      nextIndex++;\n    }\n  }\n  const result = geometry.clone();\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i];\n    const oldAttribute = geometry.getAttribute(name);\n    const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n    result.setAttribute(name, attribute);\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j];\n        const buffer2 = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n        const morphAttribute = new BufferAttribute(buffer2, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n        result.morphAttributes[name][j] = morphAttribute;\n      }\n    }\n  }\n  result.setIndex(newIndices);\n  return result;\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.\");\n    return geometry;\n  }\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex();\n    if (index === null) {\n      const indices = [];\n      const position = geometry.getAttribute(\"position\");\n      if (position !== void 0) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i);\n        }\n        geometry.setIndex(indices);\n        index = geometry.getIndex();\n      } else {\n        console.error(\n          \"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\n        );\n        return geometry;\n      }\n    }\n    const numberOfTriangles = index.count - 2;\n    const newIndices = [];\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0));\n          newIndices.push(index.getX(i));\n          newIndices.push(index.getX(i + 1));\n        }\n      } else {\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i + 2));\n          } else {\n            newIndices.push(index.getX(i + 2));\n            newIndices.push(index.getX(i + 1));\n            newIndices.push(index.getX(i));\n          }\n        }\n      }\n    }\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n    }\n    const newGeometry = geometry.clone();\n    newGeometry.setIndex(newIndices);\n    newGeometry.clearGroups();\n    return newGeometry;\n  } else {\n    console.error(\"THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:\", drawMode);\n    return geometry;\n  }\n}\nfunction computeMorphedAttributes(object) {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error(\"THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.\");\n    return null;\n  }\n  const _vA = new Vector3();\n  const _vB = new Vector3();\n  const _vC = new Vector3();\n  const _tempA = new Vector3();\n  const _tempB = new Vector3();\n  const _tempC = new Vector3();\n  const _morphA = new Vector3();\n  const _morphB = new Vector3();\n  const _morphC = new Vector3();\n  function _calculateMorphedAttributeData(object2, material2, attribute, morphAttribute, morphTargetsRelative2, a2, b2, c2, modifiedAttributeArray) {\n    _vA.fromBufferAttribute(attribute, a2);\n    _vB.fromBufferAttribute(attribute, b2);\n    _vC.fromBufferAttribute(attribute, c2);\n    const morphInfluences = object2.morphTargetInfluences;\n    if (\n      // @ts-ignore\n      material2.morphTargets && morphAttribute && morphInfluences\n    ) {\n      _morphA.set(0, 0, 0);\n      _morphB.set(0, 0, 0);\n      _morphC.set(0, 0, 0);\n      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {\n        const influence = morphInfluences[i2];\n        const morph = morphAttribute[i2];\n        if (influence === 0)\n          continue;\n        _tempA.fromBufferAttribute(morph, a2);\n        _tempB.fromBufferAttribute(morph, b2);\n        _tempC.fromBufferAttribute(morph, c2);\n        if (morphTargetsRelative2) {\n          _morphA.addScaledVector(_tempA, influence);\n          _morphB.addScaledVector(_tempB, influence);\n          _morphC.addScaledVector(_tempC, influence);\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence);\n          _morphB.addScaledVector(_tempB.sub(_vB), influence);\n          _morphC.addScaledVector(_tempC.sub(_vC), influence);\n        }\n      }\n      _vA.add(_morphA);\n      _vB.add(_morphB);\n      _vC.add(_morphC);\n    }\n    if (object2.isSkinnedMesh) {\n      object2.boneTransform(a2, _vA);\n      object2.boneTransform(b2, _vB);\n      object2.boneTransform(c2, _vC);\n    }\n    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;\n    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;\n    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;\n    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;\n    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;\n    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;\n    modifiedAttributeArray[c2 * 3 + 0] = _vC.x;\n    modifiedAttributeArray[c2 * 3 + 1] = _vC.y;\n    modifiedAttributeArray[c2 * 3 + 2] = _vC.z;\n  }\n  const geometry = object.geometry;\n  const material = object.material;\n  let a, b, c;\n  const index = geometry.index;\n  const positionAttribute = geometry.attributes.position;\n  const morphPosition = geometry.morphAttributes.position;\n  const morphTargetsRelative = geometry.morphTargetsRelative;\n  const normalAttribute = geometry.attributes.normal;\n  const morphNormal = geometry.morphAttributes.position;\n  const groups = geometry.groups;\n  const drawRange = geometry.drawRange;\n  let i, j, il, jl;\n  let group, groupMaterial;\n  let start, end;\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n  if (index !== null) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j);\n          b = index.getX(j + 1);\n          c = index.getX(j + 2);\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(index.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i);\n        b = index.getX(i + 1);\n        c = index.getX(i + 2);\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  } else if (positionAttribute !== void 0) {\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i];\n        groupMaterial = material[group.materialIndex];\n        start = Math.max(group.start, drawRange.start);\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j;\n          b = j + 1;\n          c = j + 2;\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition\n          );\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal\n          );\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start);\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n      for (i = start, il = end; i < il; i += 3) {\n        a = i;\n        b = i + 1;\n        c = i + 2;\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition\n        );\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal\n        );\n      }\n    }\n  }\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n  return {\n    positionAttribute,\n    normalAttribute,\n    morphedPositionAttribute,\n    morphedNormalAttribute\n  };\n}\nfunction toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {\n  const creaseDot = Math.cos(creaseAngle);\n  const hashMultiplier = (1 + 1e-10) * 100;\n  const verts = [new Vector3(), new Vector3(), new Vector3()];\n  const tempVec1 = new Vector3();\n  const tempVec2 = new Vector3();\n  const tempNorm = new Vector3();\n  const tempNorm2 = new Vector3();\n  function hashVertex(v) {\n    const x = ~~(v.x * hashMultiplier);\n    const y = ~~(v.y * hashMultiplier);\n    const z = ~~(v.z * hashMultiplier);\n    return `${x},${y},${z}`;\n  }\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;\n  const posAttr = resultGeometry.attributes.position;\n  const vertexMap = {};\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = [];\n      }\n      vertexMap[hash].push(normal);\n    }\n  }\n  const normalArray = new Float32Array(posAttr.count * 3);\n  const normAttr = new BufferAttribute(normalArray, 3, false);\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i;\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);\n    tempVec1.subVectors(c, b);\n    tempVec2.subVectors(a, b);\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize();\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n];\n      const hash = hashVertex(vert);\n      const otherNormals = vertexMap[hash];\n      tempNorm2.set(0, 0, 0);\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k];\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm);\n        }\n      }\n      tempNorm2.normalize();\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);\n    }\n  }\n  resultGeometry.setAttribute(\"normal\", normAttr);\n  return resultGeometry;\n}\nexport {\n  computeMorphedAttributes,\n  estimateBytesUsed,\n  interleaveAttributes,\n  mergeBufferAttributes,\n  mergeBufferGeometries,\n  mergeVertices,\n  toCreasedNormals,\n  toTrianglesDrawMode\n};\n//# sourceMappingURL=BufferGeometryUtils.js.map\n","/**\n * Main content for the worker that handles the loading and execution of\n * modules within it.\n */\nfunction workerBootstrap() {\n  var modules = Object.create(null);\n\n  // Handle messages for registering a module\n  function registerModule(ref, callback) {\n    var id = ref.id;\n    var name = ref.name;\n    var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n    var init = ref.init; if ( init === void 0 ) init = function(){};\n    var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n    // Only register once\n    if (modules[id]) { return }\n\n    try {\n      // If any dependencies are modules, ensure they're registered and grab their value\n      dependencies = dependencies.map(function (dep) {\n        if (dep && dep.isWorkerModule) {\n          registerModule(dep, function (depResult) {\n            if (depResult instanceof Error) { throw depResult }\n          });\n          dep = modules[dep.id].value;\n        }\n        return dep\n      });\n\n      // Rehydrate functions\n      init = rehydrate((\"<\" + name + \">.init\"), init);\n      if (getTransferables) {\n        getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\n      }\n\n      // Initialize the module and store its value\n      var value = null;\n      if (typeof init === 'function') {\n        value = init.apply(void 0, dependencies);\n      } else {\n        console.error('worker module init function failed to rehydrate');\n      }\n      modules[id] = {\n        id: id,\n        value: value,\n        getTransferables: getTransferables\n      };\n      callback(value);\n    } catch(err) {\n      if (!(err && err.noLog)) {\n        console.error(err);\n      }\n      callback(err);\n    }\n  }\n\n  // Handle messages for calling a registered module's result function\n  function callModule(ref, callback) {\n    var ref$1;\n\n    var id = ref.id;\n    var args = ref.args;\n    if (!modules[id] || typeof modules[id].value !== 'function') {\n      callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n    }\n    try {\n      var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n      if (result && typeof result.then === 'function') {\n        result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n      } else {\n        handleResult(result);\n      }\n    } catch(err) {\n      callback(err);\n    }\n    function handleResult(result) {\n      try {\n        var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n        if (!tx || !Array.isArray(tx) || !tx.length) {\n          tx = undefined; //postMessage is very picky about not passing null or empty transferables\n        }\n        callback(result, tx);\n      } catch(err) {\n        console.error(err);\n        callback(err);\n      }\n    }\n  }\n\n  function rehydrate(name, str) {\n    var result = void 0;\n    self.troikaDefine = function (r) { return result = r; };\n    var url = URL.createObjectURL(\n      new Blob(\n        [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\n        {type: 'application/javascript'}\n      )\n    );\n    try {\n      importScripts(url);\n    } catch(err) {\n      console.error(err);\n    }\n    URL.revokeObjectURL(url);\n    delete self.troikaDefine;\n    return result\n  }\n\n  // Handler for all messages within the worker\n  self.addEventListener('message', function (e) {\n    var ref = e.data;\n    var messageId = ref.messageId;\n    var action = ref.action;\n    var data = ref.data;\n    try {\n      // Module registration\n      if (action === 'registerModule') {\n        registerModule(data, function (result) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: {isCallable: typeof result === 'function'}\n            });\n          }\n        });\n      }\n      // Invocation\n      if (action === 'callModule') {\n        callModule(data, function (result, transferables) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: result\n            }, transferables || undefined);\n          }\n        });\n      }\n    } catch(err) {\n      postMessage({\n        messageId: messageId,\n        success: false,\n        error: err.stack\n      });\n    }\n  });\n}\n\n/**\n * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n * thread, for when the execution environment doesn't support web workers or they\n * are disallowed due to e.g. CSP security restrictions.\n */\nfunction defineMainThreadModule(options) {\n  var moduleFunc = function() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return moduleFunc._getInitResult().then(function (initResult) {\n      if (typeof initResult === 'function') {\n        return initResult.apply(void 0, args)\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  };\n  moduleFunc._getInitResult = function() {\n    // We can ignore getTransferables in main thread. TODO workerId?\n    var dependencies = options.dependencies;\n    var init = options.init;\n\n    // Resolve dependencies\n    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) { return dep && dep._getInitResult ? dep._getInitResult() : dep; }\n    ) : [];\n\n    // Invoke init with the resolved dependencies\n    var initPromise = Promise.all(dependencies).then(function (deps) {\n      return init.apply(null, deps)\n    });\n\n    // Cache the resolved promise for subsequent calls\n    moduleFunc._getInitResult = function () { return initPromise; };\n\n    return initPromise\n  };\n  return moduleFunc\n}\n\nvar supportsWorkers = function () {\n  var supported = false;\n\n  // Only attempt worker initialization in browsers; elsewhere it would just be\n  // noise e.g. loading into a Node environment for SSR.\n  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n    try {\n      // TODO additional checks for things like importScripts within the worker?\n      //  Would need to be an async check.\n      var worker = new Worker(\n        URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))\n      );\n      worker.terminate();\n      supported = true;\n    } catch (err) {\n      if (typeof process !== 'undefined' && process.env.NODE_ENV === 'test') ; else {\n        console.log(\n          (\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\")\n        );\n      }\n    }\n  }\n\n  // Cached result\n  supportsWorkers = function () { return supported; };\n  return supported\n};\n\nvar _workerModuleId = 0;\nvar _messageId = 0;\nvar _allowInitAsString = false;\nvar workers = Object.create(null);\nvar registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\nvar openRequests = Object.create(null);\n\n\n/**\n * Define a module of code that will be executed with a web worker. This provides a simple\n * interface for moving chunks of logic off the main thread, and managing their dependencies\n * among one another.\n *\n * @param {object} options\n * @param {function} options.init\n * @param {array} [options.dependencies]\n * @param {function} [options.getTransferables]\n * @param {string} [options.name]\n * @param {string} [options.workerId]\n * @return {function(...[*]): {then}}\n */\nfunction defineWorkerModule(options) {\n  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n    throw new Error('requires `options.init` function')\n  }\n  var dependencies = options.dependencies;\n  var init = options.init;\n  var getTransferables = options.getTransferables;\n  var workerId = options.workerId;\n\n  if (!supportsWorkers()) {\n    return defineMainThreadModule(options)\n  }\n\n  if (workerId == null) {\n    workerId = '#default';\n  }\n  var id = \"workerModule\" + (++_workerModuleId);\n  var name = options.name || id;\n  var registrationPromise = null;\n\n  dependencies = dependencies && dependencies.map(function (dep) {\n    // Wrap raw functions as worker modules with no dependencies\n    if (typeof dep === 'function' && !dep.workerModuleData) {\n      _allowInitAsString = true;\n      dep = defineWorkerModule({\n        workerId: workerId,\n        name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\n        init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\n      });\n      _allowInitAsString = false;\n    }\n    // Grab postable data for worker modules\n    if (dep && dep.workerModuleData) {\n      dep = dep.workerModuleData;\n    }\n    return dep\n  });\n\n  function moduleFunc() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    // Register this module if needed\n    if (!registrationPromise) {\n      registrationPromise = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n      var unregister = function () {\n        registrationPromise = null;\n        registeredModules[workerId].delete(unregister);\n      }\n      ;(registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\n    }\n\n    // Invoke the module, returning a promise\n    return registrationPromise.then(function (ref) {\n      var isCallable = ref.isCallable;\n\n      if (isCallable) {\n        return callWorker(workerId,'callModule', {id: id, args: args})\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  }\n  moduleFunc.workerModuleData = {\n    isWorkerModule: true,\n    id: id,\n    name: name,\n    dependencies: dependencies,\n    init: stringifyFunction(init),\n    getTransferables: getTransferables && stringifyFunction(getTransferables)\n  };\n  return moduleFunc\n}\n\n/**\n * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\n * This only terminates the Worker itself; the worker module will remain available\n * and if you call it again its Worker will be respawned.\n * @param {string} workerId\n */\nfunction terminateWorker(workerId) {\n  // Unregister all modules that were registered in that worker\n  if (registeredModules[workerId]) {\n    registeredModules[workerId].forEach(function (unregister) {\n      unregister();\n    });\n  }\n  // Terminate the Worker object\n  if (workers[workerId]) {\n    workers[workerId].terminate();\n    delete workers[workerId];\n  }\n}\n\n/**\n * Stringifies a function into a form that can be deserialized in the worker\n * @param fn\n */\nfunction stringifyFunction(fn) {\n  var str = fn.toString();\n  // If it was defined in object method/property format, it needs to be modified\n  if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n    str = 'function ' + str;\n  }\n  return str\n}\n\n\nfunction getWorker(workerId) {\n  var worker = workers[workerId];\n  if (!worker) {\n    // Bootstrap the worker's content\n    var bootstrap = stringifyFunction(workerBootstrap);\n\n    // Create the worker from the bootstrap function content\n    worker = workers[workerId] = new Worker(\n      URL.createObjectURL(\n        new Blob(\n          [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\n          {type: 'application/javascript'}\n        )\n      )\n    );\n\n    // Single handler for response messages from the worker\n    worker.onmessage = function (e) {\n      var response = e.data;\n      var msgId = response.messageId;\n      var callback = openRequests[msgId];\n      if (!callback) {\n        throw new Error('WorkerModule response with empty or unknown messageId')\n      }\n      delete openRequests[msgId];\n      callback(response);\n    };\n  }\n  return worker\n}\n\n// Issue a call to the worker with a callback to handle the response\nfunction callWorker(workerId, action, data) {\n  return new Promise(function (resolve, reject) {\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        resolve(response.result);\n      } else {\n        reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n      }\n    };\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n  })\n}\n\nexport { defineWorkerModule, stringifyFunction, terminateWorker };\n","import { ShaderChunk, UniformsUtils, MeshDepthMaterial, RGBADepthPacking, MeshDistanceMaterial, ShaderLib, Matrix4, Vector3, Mesh, CylinderGeometry, Vector2, MeshStandardMaterial, DoubleSide } from 'three';\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */\nfunction expandShaderIncludes( source ) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    let chunk = ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match\n  }\n  return source.replace( pattern, replace )\n}\n\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n}\n\nfunction generateUUID() {\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n    _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n    _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n    _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase()\n\n}\n\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function(/*target, ...sources*/) {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target\n};\n\n\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object} options.defines - Custom `defines` for the material\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]()\n  }\n\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  const onBeforeCompile = function (shaderInfo, renderer) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {return Date.now() - epoch}\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\n  };\n\n  const derive = function(base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n    derived.uuid = generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n\n    return derived\n  };\n\n  const descriptor = {\n    constructor: {value: DerivedMaterial},\n    isDerivedMaterial: {value: true},\n\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n      }\n    },\n\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile\n      },\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, UniformsUtils.clone(source.uniforms));\n        }\n        return this\n      }\n    },\n\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this)\n      }\n    },\n\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDepthMaterial()\n              : new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),\n            options\n          );\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }\n    },\n\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDistanceMaterial()\n              : new MeshDistanceMaterial(),\n            options\n          );\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }\n    },\n\n    dispose: {\n      writable: true,\n      configurable: true,\n      value() {\n        const {_depthMaterial, _distanceMaterial} = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial()\n}\n\n\nfunction upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(\n      /^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n    );\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    let res = customRewriter({vertexShader, fragmentShader});\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n      match => {\n        postChunks.push(match);\n        return ''\n      }\n    );\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n    vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n    });\n\n    // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n    // Perhaps the other textures too going forward?\n    if (!(material.map && material.map.channel > 0)) {\n      vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n    }\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n  return {\n    vertexShader,\n    fragmentShader\n  }\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n    );\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n  return shaderCode\n}\n\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n}\n\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n  }\n  return id\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? ShaderLib[builtinType] : material //TODO fallback for unknown type?\n}\n\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms\n}\n\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */\nfunction invertMatrix4(srcMatrix, tgtMatrix = new Matrix4()) {\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n  return tgtMatrix\n}\n\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\n\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(\n    baseMaterial,\n    {\n      chained: true,\n      uniforms: {\n        pointA: {value: new Vector3()},\n        controlA: {value: new Vector3()},\n        controlB: {value: new Vector3()},\n        pointB: {value: new Vector3()},\n        radius: {value: 0.01},\n        dashing: {value: new Vector3()} //on, off, offset\n      },\n      vertexDefs,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro\n    }\n  )\n}\n\nlet geometry = null;\n\nconst defaultBaseMaterial = /*#__PURE__*/new MeshStandardMaterial({color: 0xffffff, side: DoubleSide});\n\n\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */\nclass BezierMesh extends Mesh {\n  static getGeometry() {\n    return geometry || (geometry =\n      new CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n    )\n  }\n\n  constructor() {\n    super(\n      BezierMesh.getGeometry(),\n      defaultBaseMaterial\n    );\n\n    this.pointA = new Vector3();\n    this.controlA = new Vector3();\n    this.controlB = new Vector3();\n    this.pointB = new Vector3();\n    this.radius = 0.01;\n    this.dashArray = new Vector2();\n    this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    this.frustumCulled = false;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    return derivedMaterial\n  }\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial()\n  }\n\n  onBeforeRender() {\n    const {uniforms} = this.material;\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n\n  raycast(/*raycaster, intersects*/) {\n    // TODO - just fail for now\n  }\n}\n\nexport { BezierMesh, createDerivedMaterial, expandShaderIncludes, getShaderUniformTypes, getShadersForMaterial, invertMatrix4, voidMainRegExp };\n","function getLang() {\n  if (navigator.languages != undefined) return navigator.languages[0];\n  return navigator.language;\n}\n\nexport { getLang };\n","const pointerEvents = {\n  onPointerEnter: () => {\n    document.body.style.cursor = \"pointer\";\n  },\n  onPointerLeave: () => {\n    document.body.style.cursor = \"default\";\n  },\n};\n\nexport default pointerEvents;\n","export const isProduction = () =>\n  process.env.NODE_ENV === \"production\" ||\n  import.meta.env.MODE === \"production\";\n"],"names":["isScreenTouchEnabled","hasTouchScreen","mQ","UA","mergeVertices","geometry","tolerance","hashToIndex","indices","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","getters","i","l","name","morphAttr","decimalShift","shiftMultiplier","index","hash","j","attribute","itemSize","k","newarray","newMorphArrays","getterFunc","m","ml","result","oldAttribute","buffer","BufferAttribute","oldMorphAttribute","buffer2","morphAttribute","toTrianglesDrawMode","drawMode","TrianglesDrawMode","TriangleFanDrawMode","TriangleStripDrawMode","position","numberOfTriangles","newGeometry","workerBootstrap","modules","registerModule","ref","callback","id","dependencies","init","getTransferables","dep","depResult","rehydrate","value","err","callModule","ref$1","args","handleResult","rej","tx","str","r","url","e","messageId","action","data","transferables","defineMainThreadModule","options","moduleFunc","len","initResult","initPromise","deps","supportsWorkers","supported","worker","_workerModuleId","_messageId","_allowInitAsString","workers","registeredModules","openRequests","defineWorkerModule","workerId","registrationPromise","stringifyFunction","callWorker","unregister","isCallable","terminateWorker","fn","getWorker","bootstrap","response","msgId","resolve","reject","voidMainRegExp","expandShaderIncludes","source","pattern","replace","match","include","chunk","ShaderChunk","_lut","generateUUID","d0","d1","d2","d3","assign","target","prop","epoch","CONSTRUCTOR_CACHE","SHADER_UPGRADE_CACHE","materialInstanceId","createDerivedMaterial","baseMaterial","optionsKey","getKeyForOptions","ctorsByDerivation","privateBeforeCompileProp","onBeforeCompile","shaderInfo","renderer","cacheKey","upgradedShaders","upgraded","upgradeShaders","DerivedMaterial","derive","base","derived","descriptor","UniformsUtils","newBase","depthMaterial","MeshDepthMaterial","RGBADepthPacking","distanceMaterial","MeshDistanceMaterial","_depthMaterial","_distanceMaterial","material","vertexShader","fragmentShader","key","vertexDefs","vertexMainIntro","vertexMainOutro","vertexTransform","fragmentDefs","fragmentMainIntro","fragmentMainOutro","fragmentColorTransform","customRewriter","timeUniform","res","postChunks","code","match1","fullStr","injectIntoShaderCode","shaderCode","defs","intro","outro","optionsJsonReplacer","_idCtr","optionsHashesToIds","optionsHash","getLang","pointerEvents","isProduction"],"mappings":"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","x_google_ignoreList":[1,2,3]}